[toc]



### 三、垃圾回收器的选择

1.吞吐量还是响应时间

首先引入两个概念：吞吐量和延迟时间

吞吐量 = CPU在用户应用程序运行的时间 / (CPU在用户应用程序运行的时间 + CPU垃圾回收的时间)

延迟时间 = 平均每次的GC的耗时

通常，吞吐优先还是响应优先这个在JVM中是一个两难之选。堆内存增大，GC一次能处理的数量变大，吞吐量大；但是GC一次的时间会变长，导致后面排队的线程等待时间变长；相反，如果堆内存小，GC一次时间短，排队等待的线程等待时间变短，延迟减少，但一次请求的数量变小(并不绝对符合)，无法同时兼顾。吞吐优先VS响应优先，是JVM调优过程中需要权衡的核心问题。

2.垃圾回收器设计上的考量

垃圾回收器的底层实现机制非常复杂，但是设计者的设计目标无外乎以下几条：

JVM在GC时不允许一边垃圾回收，一边还创建新对象(就像不能一边打扫卫生，还在一边扔垃圾)。

基于第一条GC时需要一段Stop the world的暂停时间，而STW会造成系统短暂停顿不能处理任何请求；

新生代收集频率高，性能优先，常用复制算法；老年代频次低，空间敏感，避免复制方式。

所有垃圾回收器的设计目标都是要让GC频率更少，时间更短，减少GC对系统影响！

3.CMS和G1

目前主流的垃圾回收器配置是新生代采用ParNew，老年代采用CMS组合的方式，或者是完全采用G1回收器，从未来的趋势来看，G1是官方维护和更为推崇的垃圾回收器。
![e6cefe4eea2841a83444256f617387f1.png](../../images/e6cefe4eea2841a83444256f617387f1.png)

业务系统，延迟敏感的推荐CMS；大内存服务，要求高吞吐的，采用G1回收器！下面单独就两款回收器的工作机制和适用场景进行一下说明：

### 四、CMS回收器

1.CMS垃圾回收器的工作机制

CMS主要是针对老年代的回收器，新生代的采用ParNew回收器，工作流程就是上文提到的经典复制算法，在三块区中进行流转回收，只不过采用多线程并行的方式加快了MinorGC速度。老年代是标记-清除，默认会在一次FullGC算法后做整理算法，清理内存碎片。

![1773c842a1a29791cdb3b153d6691a53.png](../../images/1773c842a1a29791cdb3b153d6691a53.png)

优点：并发收集、主打“低延时” 。在最耗时的两个阶段都没有发生STW，而需要STW的阶段都以很快速度完成。

缺点：1、消耗CPU；2、浮动垃圾；3、内存碎片

适用场景：重视服务器响应速度，要求系统停顿时间最短。

2.登录系统的压测前配置

调优场景以之前的登录系统为例，按照之前容量估算套路，引入性能压测环节，测试同学对登录接口压至1s内60M的对象生成速度，假设只配置了4C8G的机器配置，采用ParNew+CMS的组合回收器，堆内存分配4g，线程栈默认1M，初始配置如下：

-Xms4g –Xmx4g –Xmn1536m -Xss1m -XX:+UseConcMarkSweepGC
划分Eden和Surviror大小，如按照默认-XX:SurvivorRatio=8 分配规则，基于CMS的JVM运行模型粗略计算如下
![8e9ff3a637d9a56a9ca6c25750a21d83.png](../../images/8e9ff3a637d9a56a9ca6c25750a21d83.png)

基本上，可以看到20S后Eden区就满了，此时再运行的时候对象已经无法分配，会触发MinorGC，假设在这次GC后S1装入100M，马上过20S又会触发一次MinorGC，多出来的100M存活对象再加上S1区已经存在的100M，已无法顺利放入到S2区，此时就会触发JVM的动态年龄机制，将一批100M左右的对象推到老年代保存，持续运行一段时间，当老年代也满了的情况下，系统可能不到一小时候就会触发一次FullGC。

3.基于CMS的调优思路

首先采取上调Survior区容量策略：新生代划2g，维持E:S1:S2=8:1:1，此时Eden=1.6G，S=200M。60M/S速率，运行25s左右会触发一次MinorGC，回收的对象需要超过200M才触发进入老年代，对象进入老年代的几率大大降低，短命对象在几次minorGC后就释放掉了。此时的JVM配置如下：

 -Xms4g –Xmx4g –Xmn2g -Xss1m -XX:SurvivorRatio=8  -XX:+UseConcMarkSweepGC
然后再下调晋升老年代年龄，默认为15——当躲过15次MinorGC后，可进入老年代；可适当调低改值为5~10，让长寿对象应尽快去往属于它的地方，而不是在新生代来回折腾，占用空间，这样可以优化每次MinorGC的耗时。

 -Xms4g –Xmx4g –Xmn2g -Xss1m -XX:SurvivorRatio=8  -XX:MaxTenuringThreshold=15 -XX:+UseConcMarkSweepGC
再选择性的去优化老年代参数：比如老年代默认在标记清除以后会做整理，还可以在CMS的增加GC频次还是增加GC时长上做些取舍，如下是响应优先的参数调优：
![ac9b9b654c90de311c243c35d642711d.png](../../images/ac9b9b654c90de311c243c35d642711d.png)

那么最终我们可以得到一个比较适用于自身业务系统的、基于CMS回收器的JVM参数：

` -Xms4g –Xmx4g –Xmn2g -Xss1m -XX:SurvivorRatio=8  -XX:MaxTenuringThreshold=5 -XX:+UseConcMarkSweepGC  -XX:CMSInitiatingOccupancyFraction=70  -XX:+UseCMSInitiatingOccupancyOnly -XX:+AlwaysPreTouch`

### 五、G1垃圾回收器

1.CMS回收器的不足

服务启动前就需要指定新生代和老年代大小，启动了就不能动态调整了！

新生代和老年代都必须**分配独立且连续的一整块内存空间**！

所有针对老年代的操作必须扫描整个老年代空间，相同的老年代对象，堆空间越大扫描耗时越长！

2.G1回收器的设计思路

G1回收天然的适用于大内存服务器，首先G1将堆内存空间拆分为多个大小相等的Region块，Region的个数默认2048个，配置4g堆内存，每个region的大小就为2M。Region动态的属于老年代或者新生代，上一秒还是分配成新生代，经过回收以后空出来，下一秒有可能被分为老年代区。

在G1回收器这里已经不需要再提前设置新生代和老年代的大小，但是新生代仍区分Eden和Survivor区。大大降低了JVM参数的调优复杂度，**只需配置-XX:MaxGCPauseMillis=n(ms)，设置最大GC停顿时间**，剩下的交给G1回收器。G1会自动追踪每个region可以回收的大小和预估的时间，最后在真正垃圾回收的时候，尽量把垃圾回收控制在设置的时间范围内，在有限的时间内回收更多的对象。

![e032a5b52480e7702acbce7757990f64.png](../../images/e032a5b52480e7702acbce7757990f64.png)


所以综合来看，**G1主打高吞吐，特别适用多核、大内存服务(如Kafka/ElasticSearch)**。

3.G1的工作机制

新生代回收：对象优先分配Eden的Region，JVM不停给新生代分配更多的region，直到新生代占堆总大小的60%，触发MinorGC。

进入老年代对象的条件不变：达到晋升年龄；动态年龄判定；大对象等

Mix混合回收：当老年代的Region占堆内存的45%以后，触发MixGC，会分阶段多次混合回收新生代和老年代的Region。

Full GC：MixGC时发现无可用的新Region块了来分配复制的存活对象，立马触发FullGC，停止系统程序，单线程标记、清除和整理，空闲出一批Region，过程很缓慢。

![7c735a8c1064187bdd507687bb91dd42.png](../../images/7c735a8c1064187bdd507687bb91dd42.png)


4.G1的核心调优参数

G1收集器自身已经有一套预测和调整机制了，因此我们首先的选择是相信它，即调整-XX:MaxGCPauseMillis=N参数，这也符合G1的目的——让GC调优尽量简单！同时也不要自己显式设置新生代的大小(用-Xmn或-XX:NewRatio参数)，如果人为干预新生代的大小，会导致目标时间这个参数失效。

针对-XX:MaxGCPauseMillis来说，参数的设置带有明显的倾向性：调低↓：延迟更低，但MinorGC频繁，MixGC回收老年代区减少，增大Full GC的风险。调高↑：单次回收更多的对象，但系统整体响应时间也会被拉长。

针对InitiatingHeapOccupancyPercent来说，调参大小的效果也不一样：调低↓：更早触发MixGC，浪费cpu。调高↑：堆积过多代回收region，增大FullGC的风险。

5.G1调优在Kafka集群的应用

比如日志平台的Kafka集群每秒写入300M数据至内存，broker节点的配置为16C32G，假设堆内存给16g，新生代分配8g，每秒产生对象假设100M左右，差不多一分多钟就会产生一次MinorGC，CMS机制下需要等Eden满了以后，才一次性清理大约8g左右的垃圾对象，差不多会有秒级的STW停顿，如果是老年代的GC延时长则会有十秒级的STW停顿。

`-Xms16g –Xmx16g –Xmn8g -Xss1m -XX:+UseConcMarkSweepGC`
假设采用了G1回收器，适当调低最大耗时，设定MaxGCPauseMillis为100ms，并且适当调低堆使用率阈值，G1就会在允许的响应时间内自动的、多批次的去进行垃圾回收，保证每个STW的时间都不会太长。

` -Xms16g -Xmx16g -Xss1m -XX:+UseG1GC -XX:MaxGCPauseMillis=100 -XX:InitiatingHeapOccupancyPercent=40`
所以线上的kafka和ES集群，动辄32~64g的大内存，如果让CMS去整块回收十多G乃至几十G的垃圾对象，对于系统而言绝对不利！一般来说，堆内存超过8g的大内存服务器，都更推荐使用G1回收器！