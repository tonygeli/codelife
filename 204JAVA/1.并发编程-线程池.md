# 并发编程-线程池



## 1.为什么会出现线程池？

创建和销毁线程都需要时间，如果频繁地进行这两个步骤就会降低系统的效率。

## 2.ThreadPoolExecutor类

Java提供了`java.util.concurrent.ThreadPoolExecutor`类来帮助管理线程池。看下具体的源代码。

```java
public class ThreadPoolExecutor extends AbstractExecutorService {
  	public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue);
    
    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit, BlockingQueue<Runnable> workQueue,ThreadFactory threadFactory);
 
    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit, BlockingQueue<Runnable> workQueue,RejectedExecutionHandler handler);
 	  // 上面的3个构造函数都是调用这第4个构造函数
    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit, BlockingQueue<Runnable> workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler);
}
```

总共有7个参数:

1. corePoolSize – 最少的工作线程数量，即使它们处于空闲状态，除非设置了allowCoreThreadTimeOut。 the number of threads to keep in the pool, even if they are idle, unless allowCoreThreadTimeOut is set
2. maximumPoolSize – 最多工作的线程数 the maximum number of threads to allow in the pool 
3. keepAliveTime – 当工作线程多于最少的数量，能存活的时间。when the number of threads is greater than the core, this is the maximum time that excess idle threads will wait for new tasks before terminating.
4. unit – 时间的单位 the time unit for the keepAliveTime argument
5. workQueue – 保存任务的队列，由execute方法提交。the queue to use for holding tasks before they are executed. This queue will hold only the Runnable tasks submitted by the execute method.
6. threadFactory – 创建新线程时要使用的工厂 the factory to use when the executor creates a new thread
7. handler – 超过队列时如何处理任务 the handler to use when execution is blocked because the thread bounds and queue capacities are reached

## 3.看看workQueue参数

阻塞队列，用来存放可执行的任务，会对线程池的运行产生重大影响，一共有以下几种选择

```java
// 首先这是一个接口
public interface BlockingQueue<E> extends Queue<E>;   
// 看看实现
public class ArrayBlockingQueue<E> implements BlockingQueue<E>;
public class LinkedBlockingQueue<E> implements BlockingQueue<E>;
public class SynchronousQueue<E> implements BlockingQueue<E>;
```

## 4.看看handler参数

```java
ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 
ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 
ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务 
```



## 5.如何合理配置线程池的大小

一般需要根据任务的类型来配置线程池大小：

　　如果是CPU密集型任务，就需要尽量压榨CPU，参考值可以设为 *N*(CPU)+1

　　如果是IO密集型任务，参考值可以设置为2**N*(CPU)

　　当然，这只是一个参考值，具体的设置还需要根据实际情况进行调整，比如可以先将线程池大小设置为参考值，再观察任务运行情况和系统负载、资源利用率来进行适当调整。