# 2.4.2 Spring Bean依赖注入

## 一、什么是Spring中的依赖注入？

依赖注入是控制反转（IoC）的一个方面，它是一个通用概念，它可以用许多不同的方式表达。这个概念说你不创建你的对象，而是描述它们应该如何创建。您不能在代码中直接连接组件和服务，而是描述配置文件中哪些组件需要哪些服务。然后，一个容器（IOC容器）负责将其全部挂起。

## 二、有哪些不同类型的IoC（依赖注入）？

1.构造函数的依赖注入：当容器调用具有许多参数的类构造函数时，完成基于构造函数的DI，每个参数表示对其他类的依赖。
2.Setter的依赖注入：基于Setter的DI是在调用无参数构造函数或无参数静态工厂方法来实例化bean之后，通过容器调用bean上的setter方法来完成的。

## 三、Spring bean是什么？

Spring Beans是构成Spring应用程序主干的Java对象。它们由Spring IoC容器实例化，组装和管理。这些bean是使用提供给容器的配置元数据创建的（以XML定义、注解）。

```java
<bean id="testController" class="com.**.TestController" scope="prototype" init-method="init" destroy-method="destory"/>

@Controller
@RequestMapping("/")
@Scope("prototype")			// 创建多实例
public class TestController {
   @PostConstruct
   public void init() {}
   @PreDestory
   public void destory() {}
}
```

scope属性：
1.singleton： 表示在spring容器中的单例，通过spring容器获得该bean时总是返回唯一的实例；
2.prototype：与单例模式相反，表示为每一个bean请求都会提供一个实例；
3.request：在请求范围内会为每一个来自客户端的网络请求提供一个实例，在请求完成后，bean会失效并被垃圾回收器回收；
4.session：与请求范围类似，表示确保每个session中有个Bean的实例，在session过期后随之消失；
5.global-session：表示在全局会话内有效。

## 四、有三种方式向Spring 容器提供元数据:

1.XML配置文件
2.基于注解配置
3.基于Java的配置

基于Java类定义Bean配置元数据，其实就是通过Java类定义Spring配置元数据，且直接消除XML配置文件。
首先让我们看一下基于Java类如何定义Bean配置元数据，具体步骤如下：
  1.使用@Configuration注解需要作为配置的类，表示该类将定义Bean的元数据  
  2.使用@Bean注解相应的方法，该方法名默认就是Bean的名称，该方法返回值就是Bean的对象。  
  3.AnnotationConfigApplicationContext或子类进行加载基于java类的配置 
**注意**：**使用bean注解的方法不能是private、final、static的。**

基于Java方式的配置方式不是为了完全替代基于XML方式的配置，两者可以结合使用，因此可以有两种结合使用方式：
	**1.在基于Java方式的配置类中引入基于XML方式的配置文件**	

```java
<bean id="message" class="java.lang.String">
    <constructor-arg index="0" value="test"></constructor-arg>
</bean>
 
 
@Configuration("ctxConfig")
@ImportResource("classpath:com/jike/***/appCtx.xml")
public class ApplicationContextConfig {}
```

可以看到在java程序中使用**@** **ImportResource**导入了XML的配置文件

​	**2.在基于XML方式的配置文件中中引入基于Java方式的配置**

```java

<context:annotation-config/>
<bean id="ctxConfig" class=“com.jike.***..ApplicationContextConfig"/>
 
//测试类
public void testXmlConfig() {
  String configLocations[] = {" classpath:com/jike/***/appCtx.xml"};
  ApplicationContext ctx = new ClassPathXmlApplicationContext(configLocations);
}
```

可以看到在XML的配置文件当中将java的配置类当中Bean来声明，第一行的是开启注解驱动支持。
值得注意的是必须得配置 <context:annotation-config/> 在XML配置文件中。

Spring提供了一个AnnotationConfigApplicanContext类，能够直接通过标注@Configuration的Java类启动Spring容器：
**通过构造函数加载配置类:**

```java
ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConf.class);
```

**通过编码方式注册配置类：**

```java
AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
ctx.register(DaoConfig.class);
ctx.register(ServiceConfig.class);
ctx.refresh();
```

可以看到ctx注册了多个configuration类，然后通过refresh类来刷新容器以应用这些配置文件。
可以通过代码一个个的引入配置类，当然也可以使用**@Import**注解来引入配置类

**引入多个配置类：**

```java
@Configuration
@Import(DaoConfig.class)
public class ServiceConfig {}
```

**总结：不同配置方式比较**

| Bean         | XML配置文件                                                  | 注解配置                                                    | Java的配置                                           |
| ------------ | ------------------------------------------------------------ | ----------------------------------------------------------- | ---------------------------------------------------- |
| Bean定义     | <bean id=""></bean>                                          | @Component                                                  | 标注了@Configuration的java类中，类方法上标注了@Bean  |
| Bean名称     | id或name="userDao"                                           | @Component("userDao")                                       | @Bean("userDao")                                     |
| Bean注入     | 通过<property>子元素或通过p命名空间的动态属性注入            | 通过标出@Autowired，按类型匹配自动,配合@Qualifier按名称匹配 | 1.@Autowired方法入参绑定Bean 2.配置类的@Bean方法注入 |
| 生命过程方法 | 通过<bean>的init-method和destory-method属性指定Bean实现类方法名 | @PostContruct和@PreDestroy                                  | @Bean(initMethod = "", destroyMethod = "")           |
| 作用范围     | <bean>的scope属性                                            | @Scope                                                      | @Scope                                               |
| 延迟初始化   | Lazy-init,默认为default                                      | @Lazy                                                       | @Lazy                                                |



