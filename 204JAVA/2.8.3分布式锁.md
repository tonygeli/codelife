## 常见分布式锁实现

有基于redis、基于数据库、基于zookeeper或etcd等几种实现方式，下面简单对比下这几种实现方式：

### 基于redis实现

对于业务来说，redis使用比较轻便，性能也比较高，通过调研，有90%的业务都是基于redis实现分布式锁。但业务线基本上都是采用单个redis节点实现分布式锁，当redis节点发生failover时，主从节点基于异步复制保证不了数据的强一致性，有可能多个客户端同时获取到锁。Redis的作者提出了一个更安全的实现，叫做Redlock，要求通过N个完全独立的Redis节点基于Quorum机制实现分布式锁，但是N个节点数据同步问题也比较复杂。

另外，大神 Martin Kleppmann，在文章《How to do distributed locking》中对分布式锁原理进行论证，指出Redlock解决不了持有锁的客户端GC pause问题，如下图所示。

![avatar](../../images/redis_realize_1.png)

客户端1在获得锁之后发生了很长时间的GC pause，在此期间，它获得的锁过期了，而客户端2获得了锁。当客户端1从GC pause中恢复过来的时候，它不知道自己持有的锁已经过期了，它依然向共享资源（上图中是一个存储服务）发起了写数据请求，而这时锁实际上被客户端2持有，因此两个客户端的写请求就有可能冲突（锁的互斥作用失效了）。除了GC pasue场景，时钟跳跃也会引发同样的问题，解决这个问题，Martin提出可以引入fencing token，即锁的版本号，在锁持有者放生变更时fencing token递增更新，客户端访问共享资源时携带着这个fencing token，这样提供共享资源的服务就能根据它进行检查，拒绝掉延迟到来的访问请求（避免了冲突），如下图所示。

![avatar](../../images/redis_realize_2.png)

Redis分布式锁引入fencing token机制，为了保证释放锁的安全性，即每个客户端只能释放自己持有的锁，必须使用lua脚本或者事务机制实现GET、比较、DEL这三步操作的原子性（类似于乐观锁机制），使用起来也不是特别方便。

总体来说，如果想要使用redis实现一套特别可靠的分布式锁服务，还是比较复杂的，对于吞吐量比较高并且有一定容错机制的服务，可以考虑直接采用单redis节点的分布式锁方案。

### 基于Zookeeper实现

基于Zookeeper临时有序节点实现分布式锁，通过ZAB协议保证数据一致性。具有Watch功能，可以高效实现阻塞锁。不过业务需要单独部署Zookeeper集群，每个lockkey需要关联一个客户端连接session，不够灵活，性能较差；

### 基于ETCD实现

采用etcd自带的kv存储，通过lockkey的状态值控制锁的获取与释放，基于Raft协议保证数据一致性，支持TTL与watch机制。同样，业务需要单独部署集群，客户端直连etcd的方式不太友好，需要封装客户端或代理层，单Raft group同步数据，服务端总并发能力略低。

### 基于数据库实现

通过数据库写操作的原子特性（unique key）或数据库排他锁实现，实现简单。但不支持TTL机制，如果释放锁sql语句执行失败，有可能产生死锁，性能也比较低。