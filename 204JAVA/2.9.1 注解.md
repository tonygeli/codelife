# Annotations注释

Java平台始终具有各种临时注释机制。例如，`transient`修饰符是一个临时注释，指示字段应被序列化子系统忽略，而 `@deprecated` javadoc标记是一个临时注释，指示该方法不再使用。从5.0版开始，该平台具有通用注释（也称为*元数据*）功能，该功能允许您定义和使用自己的注释类型。该工具包括用于声明注释类型的语法，用于注释声明的语法，用于读取注释的API，用于注释的类文件表示以及注释处理工具。

注释不会直接影响程序的语义，但会影响工具和库对程序的处理方式，进而会影响正在运行的程序的语义。可以从1源文件，2class文件读取注释，也可以在3运行时通过反射读取注释。

注释是对javadoc标签的补充。通常，如果标记旨在影响或产生文档，则标记可能应该是javadoc标记；否则，标记应为javadoc标记。否则，它应该是一个注释。

注释：在interface关键字之前加一个符号（@）。每个方法声明都定义了注释类型的` element`。方法声明必须没有任何参数或`throws`子句。返回类型仅限于原语，`String`，`enums`，`annotations` 和 `arrays`。方法可以具有*默认值*。这是注释类型声明的示例：

```java
/**
 * 带注释的API进行增强请求 Request-For-Enhancement(RFE) 
 */
public @interface RequestForEnhancement {
    int    id();
    String synopsis();
    String engineer() default "[unassigned]"; 
    String date() default "[unimplemented]"; 
}
```

定义注释类型后，您可以使用它来注释声明。 注释是一种特殊的修饰符，使用方式和其他修饰符（例如 `public`，` static`或`final`）。 按照惯例，注释在其他修饰符之前。 注释包括一个符号（@），后跟一个注释类型和一个键-值对的括号列表。 该值必须是编译时常量。 这是带有与上面声明的注释类型相对应的注释的方法声明： 

```java
@RequestForEnhancement(
    id       = 2868724,
    synopsis = "Enable time-travel",
    engineer = "Mr. Peabody",
    date     = "4/1/3007"
)
public static void travelThroughTime(Date destination) { ... }
```

没有元素的注释类型称为`marker`注释类型，例如： 

```java
/** 指示带注释的API元素的规范是初步的，随时可能更改。 */
public @interface Preliminary { }
```

可以省略标记注释中的括号，如下所示：

```java
@Preliminary public class TimeTravel { ... }
```

在具有单个元素的注释中，该元素应命名`value`，如下所示： 

```java
public @interface Copyright {
    String value();
}
```

允许在元素名称`value`的单元素注释中省略元素名称和等号（`=`），如下所示：

```java
@Copyright("2002 Yoyodyne Propulsion Systems")
public class OscillationOverthruster { ... }
```

将代码联系在一起，我们将构建一个简单的基于注释的测试框架。 首先，我们需要一个标记注释类型来指示一个方法是一种测试方法，并且应该由测试工具来运行：

```java
import java.lang.annotation.*;
/** 指示带注释的方法是测试方法。此注释仅应在无参数静态方法上使用。*/
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Test { }
```

注意，注释类型声明本身是带注释的。 这种注释称为`元注释`。 第一个（`@Retention(RetentionPolicy.RUNTIME)`）表示该类型的注释将由VM保留，以便可以在运行时以反射方式读取它们。 第二个（`@Target(ElementType.METHOD)`）指示此注释类型只能用于方法声明。

RetentionPolicy有3个值：`CLASS RUNTIME  SOURCE`
按生命周期来划分可分为3类：
1.`RetentionPolicy.SOURCE`：注解只保留在源文件，当Java文件编译成class文件的时候，注解被遗弃；
2.`RetentionPolicy.CLASS`：注解被保留到class文件，但jvm加载class文件时候被遗弃，这是默认的生命周期；
3.`RetentionPolicy.RUNTIME`：注解不仅被保存到class文件中，jvm加载class文件之后，仍然存在；

```java
public class Foo {
   @Test public static void m1() { }
   public static void m2() { }
   @Test public static void m3() {
       throw new RuntimeException("Boom");
   }
   public static void m4() { }
   @Test public static void m5() { }
   public static void m6() { }
   @Test public static void m7() {
       throw new RuntimeException("Crash");
   }
   public static void m8() { }
}

import java.lang.reflect.*;

public class RunTests {
public static void main(String[] args) throws Exception {
   int passed = 0, failed = 0;
   for (Method m : Class.forName(args[0]).getMethods()) {
      if (m.isAnnotationPresent(Test.class)) {
         try {
            m.invoke(null);
            passed++;
         } catch (Throwable ex) {
            System.out.printf("Test %s failed: %s %n", m, ex.getCause());
            failed++;
         }
      }
   }
   System.out.printf("Passed: %d, Failed %d%n", passed, failed);
}
}
```

该工具将类名作为命令行参数，并遍历命名类的所有方法，以尝试调用用`@Test`注释类型（上面定义）进行注释的每个方法。 反映性查询以绿色突出显示以找出方法是否具有`@Test`注释。 如果测试方法调用引发异常，则认为测试已失败，并打印失败报告。 最后，将打印摘要，显示通过和失败的测试数量。 这是在`Foo`程序上运行测试工具时的外观（上图）：

```java
$ java RunTests Foo
Test public static void Foo.m3() failed: java.lang.RuntimeException: Boom 
Test public static void Foo.m7() failed: java.lang.RuntimeException: Crash 
Passed: 2, Failed 2
```

尽管此测试工具显然是玩具，但它演示了注释的功能，可以轻松扩展以克服其局限性。 