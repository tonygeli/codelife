[toc]



# 1、什么是 Mybatis？ 

1.Mybatis 是⼀个半 ORM（对象关系映射）框架，它内部封装了 JDBC，开发 时只需要关注 SQL 语句本身，不需要 花费精⼒去处理加载驱动、创建连接、 创 建 statement 等繁杂的过程。程序员直 接编写原⽣态 sql，可以严格控制 sql执⾏性能，灵活度⾼。 
2.MyBatis 可以使⽤ XML 或注解来配 置和映射原⽣信息，将 POJO 映射成数据库中的记 录 ，避免了⼏乎所有的JDBC代码和⼿动设置参数以及获取结果集。 
3.通过 xml ⽂件或注解的⽅式将要执⾏的各种 statement 配置起来，并通过 java 对象和 statement 中 sql 的动态参数进⾏映射⽣成最终执⾏的 sql 语句，最后由 mybatis 框架执⾏ sql 并将结果映射为 java 对象并返回。（从执⾏ sql 到返回result 的过程）。 

# 2.MyBatis的优点

1.基于 SQL 语句编程，相当灵活，不会对应⽤程序或者数据库的现有设计造成任何影响，SQL 写在 XML ⾥，解除 sql 与程序代码的耦合，便于统⼀管理；提供 XML 标签，⽀持编写动态 SQL 语 句，并可重⽤。 
2.与 JDBC 相⽐，减少了 50%以上的 代码量，消除了 JDBC ⼤量冗余的代 码， 不需要⼿动开关连接；
3.很 好 的 与 各 种 数 据 库 兼 容 （ 因 为 MyBatis 使⽤ JDBC 来连接数据库，所 以 只要 JDBC ⽀持的数据库 MyBatis 都⽀持）。 
4.能够与 Spring 很好的集成；
5.提供映射标签，⽀持对象与数据库的 ORM 字段关系映射；提供对象关系映 射标签，⽀持对象关系组件维护。

# 3.MyBatis 框架的缺点：

1.SQL 语句的编写⼯作量较⼤，尤其当 字段多、关联表多时，对开发⼈员编写 SQL 语句的功底有⼀定要求。 
2.SQL 语句依赖于数据库，导致数据库 移植性差，不能随意更换数据库。

# 4、MyBatis 框架适⽤场合：

1.MyBatis 专注于 SQL 本身，是⼀个⾜ 够灵活的 DAO 层解决⽅案。 
2.对性能的要求很⾼，或者需求变化较 多的项⽬，如互联⽹项⽬，MyBatis 将 是不错的选择。

# 5、MyBatis 与 Hibernate 有哪些不同？

 1.Mybatis 和 hibernate 不同，它不完全是

## 2.MYBATIS之MAPPER接口的注册过程

Mapper接口用于定义执行SQL语句相关的方法，方法名一般和Mapper XML配置文件中<select|update|delete|insert>标签的id属性相同，接口的完全限定名一般对应Mapper XML配置文件的命名空间。

可以看一下Mapper XML，如下面的UserMapper.xml

```
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.blog4java.mybatis.example.mapper.UserMapper">
    <sql id="userAllField">
      id,create_time, name, password, phone, nick_name
    </sql>

    <select id="listAllUser"   resultType="com.blog4java.mybatis.example.entity.UserEntity" >
        select
        <include refid="userAllField"/>
        from user
    </select>

    <select id="getUserByEntity"  resultType="com.blog4java.mybatis.example.entity.UserEntity">
        select
        <include refid="userAllField"/>
        from user
        <where>
            <if test="id != null">
                AND id = #{id}
            </if>
            <if test="name != null">
                AND name = #{name}
            </if>
            <if test="phone != null">
                AND phone = #{phone}
            </if>
        </where>
    </select>

    <select id="getUserByPhone" resultType="com.blog4java.mybatis.example.entity.UserEntity">
        select
        <include refid="userAllField"/>
        from user
        where phone = ${phone}
    </select>
</mapper>
```

UserMapper的代码

```
public interface UserMapper {

    List<UserEntity> listAllUser();

    List<UserEntity> getUserByEntity( UserEntity user);

    UserEntity getUserByPhone(@Param("phone") String phone);

}
```

看一下如何执行这个UserMapper.xml，参考下面的代码

```
// 获取配置文件输入流
InputStream inputStream = Resources.getResourceAsStream("mybatis-config.xml");
// 通过SqlSessionFactoryBuilder的build()方法创建SqlSessionFactory实例
SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
// 调用openSession()方法创建SqlSession实例
SqlSession sqlSession = sqlSessionFactory.openSession();
// 获取UserMapper代理对象
UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
// 执行Mapper方法，获取执行结果
List<UserEntity> userList = userMapper.listAllUser();

System.out.println(JSON.toJSONString(userList));
```

如上面的代码所示，在创建SqlSession实例后，需要调用SqlSession的getMapper()方法获取一个UserMapper的引用，然后通过该引用调用Mapper接口中定义的方法，UserMapper是一个接口，我们调用SqlSession对象getMapper()返回的到底是什么呢？

我们知道，接口中定义的方法必须通过某个类实现该接口，然后创建该类的实例，才能通过实例调用方法。所以SqlSession对象的getMapper()方法返回的一定是某个类的实例。具体是哪个类的实例呢？实际上getMapper()方法返回的是一个动态代理对象。

我们一步步解析 DefaultSqlSession实现了SqlSession接口，可以直接看一下DefaultSqlSession对getMapper()的具体实现

```
// SqlSession对象getMapper()具体的实现
@Override
public <T> T getMapper(Class<T> type) {
  return configuration.<T>getMapper(type, this);  // this:sqlSession
}

// 通过调用configuration类的getMapper获取UserMapper的实列，继续看看getMapper的实现
public class Configuration {  // configuration类的getMapper的实现
  public <T> T getMapper(Class<T> type, SqlSession sqlSession) {
    return mapperRegistry.getMapper(type, sqlSession);
  }
}
```

configuration类的getMapper的是通过调用mapperRegistry的getMapper方法来实现的

**这里的mapperRegistry用于注册Mapper接口信息，建立Mapper接口的Class对象和MapperProxyFactory对象之间的关系，其中MapperProxyFactory对象用于创建Mapper动态代理对象**

继续下一步

![Mybatis之Mapper接口的注册过程](file:///Users/admin/Documents/note/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/%E7%AC%94%E8%AE%B0/images/4925ef65d1764d2abeab75982197f6d6.png?lastModify=1623470232)

根据Mapper接口Class对象获取Mapper动态代理对象

Mapper动态代理对象是通过MapperProxyFactory创建的。

重点来了，MapperProxyFactory如何通过动态代理来创建Mapper对象的

![Mybatis之Mapper接口的注册过程](file:///Users/admin/Documents/note/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/%E7%AC%94%E8%AE%B0/images/658577fd8f6e4bfb94945b74192bb7d5.png?lastModify=1623470232)

MapperProxy使用的是JDK内置的动态代理

MapperProxy使用的是JDK内置的动态代理，实现了InvocationHandler接口，invoke()方法中为通用的拦截逻辑，具体内容在介绍Mapper方法调用过程时再做介绍。使用JDK内置动态代理，通过MapperProxy类实现InvocationHandler接口，定义方法执行拦截逻辑后，还需要调用java.lang.reflect.Proxy类的newProxyInstance()方法创建代理对象。

MyBatis对这一过程做了封装，使用MapperProxyFactory创建Mapper动态代理对象。

![Mybatis之Mapper接口的注册过程](file:///Users/admin/Documents/note/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/%E7%AC%94%E8%AE%B0/images/19f7239d661149ca847ea7171a542faf.png?lastModify=1623470232)

MapperProxyFactory类对jdk动态代理做了进一步的封装

如上面的代码所示，MapperProxyFactory类的工厂方法newInstance()是非静态的。也就是说，使用MapperProxyFactory创建Mapper动态代理对象首先需要创建MapperProxyFactory实例。MapperProxyFactory实例是什么时候创建的呢？

Configuration对象中有一个mapperRegistry属性，创建Configuration对象过程中，[具体看这篇文章](https://www.toutiao.com/item/6956133794403435038/)，解析<mappers>标签的时候会调用mapperRegistry中的addMapper(Class<T> type)，创建MapperProxyFactory实例。

MyBatis通过mapperRegistry属性注册Mapper接口与MapperProxyFactory对象之间的对应关系。下面是MapperRegistry类的代码

```
public class MapperRegistry {
  // Configuration对象引用
  private final Configuration config;
  // 用于注册Mapper接口Class对象，和MapperProxyFactory对象对应关系
  private final Map<Class<?>, MapperProxyFactory<?>> knownMappers = new HashMap<Class<?>, MapperProxyFactory<?>>();

  public MapperRegistry(Configuration config) {
    this.config = config;
  }
  // 根据Mapper接口Class对象获取Mapper动态代理对象
  @SuppressWarnings("unchecked")
  public <T> T getMapper(Class<T> type, SqlSession sqlSession) {
    final MapperProxyFactory<T> mapperProxyFactory = (MapperProxyFactory<T>) knownMappers.get(type);
    if (mapperProxyFactory == null) {
      throw new BindingException("Type " + type + " is not known to the MapperRegistry.");
    }
    try {
      return mapperProxyFactory.newInstance(sqlSession);
    } catch (Exception e) {
      throw new BindingException("Error getting mapper instance. Cause: " + e, e);
    }
  }
  
  public <T> boolean hasMapper(Class<T> type) {
    return knownMappers.containsKey(type);
  }
  // 根据Mapper接口Class对象，创建MapperProxyFactory对象，并注册到knownMappers属性中
  public <T> void addMapper(Class<T> type) {
    if (type.isInterface()) {
      if (hasMapper(type)) {
        throw new BindingException("Type " + type + " is already known to the MapperRegistry.");
      }
      boolean loadCompleted = false;
      try {
        knownMappers.put(type, new MapperProxyFactory<T>(type));
        // It's important that the type is added before the parser is run
        // otherwise the binding may automatically be attempted by the
        // mapper parser. If the type is already known, it won't try.
        MapperAnnotationBuilder parser = new MapperAnnotationBuilder(config, type);
        parser.parse();
        loadCompleted = true;
      } finally {
        if (!loadCompleted) {
          knownMappers.remove(type);
        }
      }
    }
  }

  /**
   * @since 3.2.2
   */
  public Collection<Class<?>> getMappers() {
    return Collections.unmodifiableCollection(knownMappers.keySet());
  }

  /**
   * @since 3.2.2
   */
  public void addMappers(String packageName, Class<?> superType) {
    ResolverUtil<Class<?>> resolverUtil = new ResolverUtil<Class<?>>();
    resolverUtil.find(new ResolverUtil.IsA(superType), packageName);
    Set<Class<? extends Class<?>>> mapperSet = resolverUtil.getClasses();
    for (Class<?> mapperClass : mapperSet) {
      addMapper(mapperClass);
    }
  }

  /**
   * @since 3.2.2
   */
  public void addMappers(String packageName) {
    addMappers(packageName, Object.class);
  }
  
}
```

如上面的代码所示，MapperRegistry类有一个knownMappers属性，用于注册Mapper接口对应的Class对象和MapperProxyFactory对象之间的关系。另外，MapperRegistry提供了addMapper()方法，用于向knownMappers属性中注册Mapper接口信息。在addMapper()方法中，为每个Mapper接口对应的Class对象创建一个MapperProxyFactory对象，然后添加到knownMappers属性中。

MapperRegistry还提供了getMapper()方法，能够根据Mapper接口的Class对象获取对应的MapperProxyFactory对象，然后就可以使用MapperProxyFactory对象创建Mapper动态代理对象了。

MyBatis框架在应用启动时会解析所有的Mapper接口，然后调用MapperRegistry对象的addMapper()方法将Mapper接口信息和对应的MapperProxyFactory对象注册到MapperRegistry对象中。





## 3.从源码层面解释：为什么执行MYBATIS接口就可以执行SQL？



# 1:场景分析

在我们使用SpringBoot+MyBatis的时候，我们一般是先引入依赖，然后配置

```
mybatis:
      mapper-locations: classpath:mapper/*.xml
      type-aliases-package: com.coco.pojo
复制代码
```

当然还要在启动类上加上一个注解

![从源码层面解释：为什么执行MyBatis接口就可以执行SQL？](file:///Users/admin/Documents/note/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/%E7%AC%94%E8%AE%B0/images/3937db9fa56947899d61bc78a04a819d.jpeg?lastModify=1623470232)



这时候，就可以编写一个接口，然后调用这个方法就可以执行配置文件中对应的SQL语句了

![从源码层面解释：为什么执行MyBatis接口就可以执行SQL？](file:///Users/admin/Documents/note/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/%E7%AC%94%E8%AE%B0/images/5c8dd828dee64ec6b031c80c0a745d6b.jpeg?lastModify=1623470232)



那么底层原理到底是怎么实现的呢？？

# 2:万事开头难

分析一个框架源码的时候最难的就是不知道该从哪开始，我是这样想的，既然我们只要写一个这样的接口，那么就可以调用对应的SQL语句，那么肯定是在哪个环节对这个接口做一些特殊的处理

我们在启动类上加了一个注解，而且注解中的包路径正是我们接口的路径，这时候我们就有点眉目了。

进入 **@MapperScan("com.coco.mapper")** 这个注解中

![从源码层面解释：为什么执行MyBatis接口就可以执行SQL？](file:///Users/admin/Documents/note/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/%E7%AC%94%E8%AE%B0/images/2aba0c9e45b1412fb74acd771cebf494.jpeg?lastModify=1623470232)



我们看到除了注解的基本三个注解之外，还有一个注解就是 **@Import({ MapperScannerRegistrar.class})** ，很多小伙伴可能不知道这个注解有什么用，我们先解释一下

# 3: SPRINGBOOT中@IMPORT注解的作用

在SpringBoot中当我们要声明一个Bean的时候，我们可以在该类上加上 **@Service，@Compont** 等，或者是在配置类中加上 **@Bean** 这个注解，除此之外还有一种方法，就是 **@Import**

@Import注解中会标明一个类，而且在SpringBoot启动的时候会处理也就是会实例化这个Bean，也就是会对这个Bean做一些处理

# 4: MAPPERSCANNERREGISTRAR.CLASS的作用

即然知道了 **@Import** 注解的作用，那现在我们进入到这个类中看看，这个类实现了** ImportBeanDefinitionRegistrar** 这个接口

![从源码层面解释：为什么执行MyBatis接口就可以执行SQL？](file:///Users/admin/Documents/note/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/%E7%AC%94%E8%AE%B0/images/09a4d2ca48d740c38f33a061b1b4aa51.png?lastModify=1623470232)



这个接口有什么用呢？？简单的来说就是MyBatis通过这个入口可以让Spring扫描到某些Bean，并且这些Bean会被Spring所管理，也就是说这些Bean会被Spring进行初始化。

所以我们自定义的Mapper接口会被Spring扫描到，然后会被Spring进行加载

ImportBeanDefinitionRegistrar这个接口就代表着当把Bean生成了对应的 **BeanDefinition** 的时候，就会调用这个接口的方法，我们看下这个接口中定义的方法

![从源码层面解释：为什么执行MyBatis接口就可以执行SQL？](file:///Users/admin/Documents/note/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/%E7%AC%94%E8%AE%B0/images/01a26972e56f4587b43fa1a81eced2e1.png?lastModify=1623470232)



这个方法做什么的呢？？

Spring在加载Bean的时候，首先会将Bean生成一个个的对应的 **BeanDefinition** ，后续就会通过这些一个个的 **BeanDefinition** 来进行初始化，也就是生成对应的Bean。

简而言之：Spring会通过MyBatis提供的 **@MapperScan("com.coco.mapper")** 这个注解会扫描我们自定义的Mapper接口，然后Spring就会为这些Mapper接口生成对应的 **BeanDefinition**

# 5: DEBUG模式进入源码

![从源码层面解释：为什么执行MyBatis接口就可以执行SQL？](file:///Users/admin/Documents/note/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/%E7%AC%94%E8%AE%B0/images/16b84ced71b647ec85e74efd16a3c789.jpeg?lastModify=1623470232)



然后debug模式启动SpringBoot项目，当然前提是整合了MyBatis哈，这个方法我进行了截取，其实只需要关注下面这几行代码就行

```
@Override
  public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
    
    //获取到MapperScan注解
    AnnotationAttributes annoAttrs = AnnotationAttributes.fromMap(importingClassMetadata.getAnnotationAttributes(MapperScan.class.getName()));
    
    ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);

    // 获取MapperScan注解中basePackages的属性值
    for (String pkg : annoAttrs.getStringArray("basePackages")) {
      if (StringUtils.hasText(pkg)) {
        basePackages.add(pkg);
      }
    }
    // 真正开始处理这个包路径下的接口，也就是我们的Mapper接口
    scanner.doScan(StringUtils.toStringArray(basePackages));
  }
  
复制代码
```

这里就可以获取到我们自定义mapper接口的包的全路径了

![从源码层面解释：为什么执行MyBatis接口就可以执行SQL？](file:///Users/admin/Documents/note/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/%E7%AC%94%E8%AE%B0/images/22ee326e02bc46fbadd26be350a682d6.jpeg?lastModify=1623470232)



# 6: 开始处理MAPPER接口

我们进入到上面的 scanner.doScan(StringUtils.toStringArray(basePackages)); 这个方法

![从源码层面解释：为什么执行MyBatis接口就可以执行SQL？](file:///Users/admin/Documents/note/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/%E7%AC%94%E8%AE%B0/images/fa6b19fd5327477bbb2bdd1ab836f7d8.jpeg?lastModify=1623470232)



然后进入 **Set beanDefinitions = super.doScan(basePackages);** 发现好多代码，其实这个方法的返回值是一个 **BeanDefinitionHolder** 的集合，而 **BeanDefinitionHolder** 就是bean的名称和该bean的BeanDefinition的组成

其实到这里我们应该能明白，这个方法的作用就是：扫描我们自定义的Mapper接口，然后为每一个接口生成一个对应的BeanDefinition，然后将其返回

![从源码层面解释：为什么执行MyBatis接口就可以执行SQL？](file:///Users/admin/Documents/note/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/%E7%AC%94%E8%AE%B0/images/a70eaf14689641b48a0d5a020a0fb4ea.png?lastModify=1623470232)



```
protected Set<BeanDefinitionHolder> doScan(String... basePackages) {
                Assert.notEmpty(basePackages, "At least one base package must be specified");
                Set<BeanDefinitionHolder> beanDefinitions = new LinkedHashSet<>();
                for (String basePackage : basePackages) {
                        Set<BeanDefinition> candidates = findCandidateComponents(basePackage);
                        for (BeanDefinition candidate : candidates) {
                                ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);
                                candidate.setScope(scopeMetadata.getScopeName());
                                String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);
                                if (candidate instanceof AbstractBeanDefinition) {
                                        postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);
                                }
                                if (candidate instanceof AnnotatedBeanDefinition) {
                                        AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);
                                }
                                if (checkCandidate(beanName, candidate)) {
                                        BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);
                                        definitionHolder =
                                                        AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
                                        beanDefinitions.add(definitionHolder);
                                        registerBeanDefinition(definitionHolder, this.registry);
                                }
                        }
                }
                return beanDefinitions;
        }
复制代码
```

![从源码层面解释：为什么执行MyBatis接口就可以执行SQL？](file:///Users/admin/Documents/note/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/%E7%AC%94%E8%AE%B0/images/281b2ea126e541e39f4f0aa4afe8fffa.png?lastModify=1623470232)



我们debug到这一步可以看到返回值，也证实了我们之前说的

# 7: 拿到BEANDEFINITION之后的处理

现在我们来看下 **processBeanDefinitions(beanDefinitions);** 这个方法，因为之前我们已经拿到了Mapper接口的BeanDefinition了，所以接下来就要进一步的处理

这个方法的代码依旧很多，我这里就不贴出来了，这里我先说一下这个方法是干什么的。

Spring在初始化Bean之前，我们是可以改变Bean的BeanDefinition的属性值得，而这个方法做的事情就是这个，经过这个方法处理之后，我们之前得到的BeanDefiniton会发生一些改变。我这里贴出二张图进行对比一下

# 这是之前的：

![从源码层面解释：为什么执行MyBatis接口就可以执行SQL？](file:///Users/admin/Documents/note/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/%E7%AC%94%E8%AE%B0/images/e86c7c377179442fbd8ce481e7e3cc6f.jpeg?lastModify=1623470232)



# 这是经过该方法处理之后的：

![从源码层面解释：为什么执行MyBatis接口就可以执行SQL？](file:///Users/admin/Documents/note/%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/%E7%AC%94%E8%AE%B0/images/e6cca4863df54c728865ceb9a2448cb3.jpeg?lastModify=1623470232)



可以发现该Bean的 **beanClass** 属性变了，已经不再是我们自定义的Bean的class了

改变之后有什么问题呢？？

Spring在初始化Bean的时候，会拿到该Bean的BenDefinition，然后就是根据 **beanClass** 这个属性值初始化Bean，本来我们Mapper接口初始化之后应该就是我们自己定义的Bean，也就是我们执行a.getClass的值应该是 com.xxx.a 这种形式的

但是现在变了，也就是说我们自定义的Mapper接口在被Spring初始化之后，再执行a.getClass会变成** org.mybatis.spring.mapper.MapperFactoryBean**

# 8: 初始化BEAN

经过上面的步骤之后，我们是拿到了Mapper接口的BeanDefinition，现在Spring就要开始初始化这些Bean了

因为此时就涉及到了Spring的源码了，我这里就不细说了

大致的流程：

1: Spring在初始化bean的时候，会根据Bean的scope属性进行初始化，而我们自定义的Mapper接口由于BeanDefinition的beanClass属性被修改了，所以在初始化的时候，经过一系列的判断最终会由MyBatis中的 **MapperProxy** 生成一个代理类，底层是通过jdk动态代理实现的

2: 然后当我们调用Mapper接口方法的时候就会执行 **invoke** 方法，因为是jdk动态代理生成的代理类。

3: 这时候，MyBatis是可以拿到该方法所在的类和该类的全路径的，比如我们在 **com.coco.mapper** 包下自定义了一个 **TestMapper** 接口，然后里面有一个 test() 方法，这时候我们可以通过一系列的方法得到一个值，该值就是:** com.coco.mapper.TestMapper.test** , 也就是该Mapper接口的全路径+方法名

4: MyBatis在解析xml配置文件的时候，有一个 **namespace** 的属性，它的值就是Mapper接口的全路径名，然后加上 id 的值，MyBatis底层会将所有的这种路径全都保存在一个Map中，然后执行接口方法的时候就会根据第3步生成的值去匹配，就能拿到对应的SQL语句了

```
<?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
    <mapper namespace="com.coco.mapper.TestMapper">
        <select id="test">
           select * from test
        </select>
    </mapper>
复制代码
```
