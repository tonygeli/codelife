```java
Object o = new Object();
```

1.**解释下对象的创建过程**

分配空间 初始化 引用赋值

```java
class T {
  int m = 8;
}

T t = new T();

0 new #2 <T>		// 分配空间
3 dup
4 invokespecial #3 <T.<init>>	// 初始化
7 astore_1			// 引用赋值
8 return
```

2.DCL单例 double check lock 到底需不需要volatile

```java
if (INSTANCE == null) {
	synchronized(Mg.class) {
    if (INSTANCE == null) {
      /**
      * 没加volatile 指令重排后，先引用赋值
      * INSTANCE != null
      */
      INSTANCE = new Mg();			 
    }
  }
}
return INSTANCE;
```

3.对象在内存中的存储布局

- 1.Markword                           8B
- 2.Class pointer类型指针        4B
- 3.instance data示例对象
- 4.padding 对齐

4.对象头信息

5.对象怎么定位

6.对象怎么分配

7.内存多少字节

new Object(); 16字节





### 1.最顶级的异常类是什么，什么情况下会用到，他的子类有什么，error什么时候会用到

***\*Throwable\**：** 有两个重要的子类：Exception（异常）和 Error（错误）

***\*Error（错误）\**:**是程序无法处理的错误  OutOfMemoryError

***\*Exception（异常）\**:**是程序本身可以处理的异常。Exception 类有一个重要的子类 RuntimeException 



### 2.java语法糖有了解吗

**自动装箱与拆箱**

**可变参数**  

```java
public static void print(String... strs) { 
    for (int i = 0; i < strs.length; i++)  
        System.out.println(strs[i]); 
} 
```

**Lambda表达式**



### 3.String a ,b,c; a=“a”;b=“b”;c==“a”+“b”; a+b==c?



### 4.怎么一行代码把1,2,3，三个数字放到一个list

Arrays.asList(1, 2, 3);



### 5.JVM内存模型、垃圾回收算法



### 6.怎么做到栈溢出

递归



### 7.新生代和老年代的比例大小，怎么设置老年代的比例

-Xmx 最大堆内存

-Xms 最小堆内存

-XX:SurvivorRatio 设置eden:from:to的比例 默认是8 实际默认并不一定

-XX:NewRatio 新生代与老年代的比率 默认是2，老年代是新生代的2倍



非堆空间也是持久代，方法区，jdk8以后的元数据区。

-XX:PermSize 初始永久代的大小

-XX:MaxPermSize 最大永久代的大小 注意永久代就是通常指的方法区，保存类信息，常量表等，在jdk8中已经废弃了永久代，而是用元数据去代取，默认的非常大可以用：

持久代的空间与我们的类的大小有很大的关系，类加载后放着持久代，如果不是频繁使用动态字节码技术、发射、OSGI等技术，持久代的大小基本上可以预估的，测试环境是多少，上线后基本没有差别。

-XX:**MaxMetaspaceSize**配置最大元数据区的大小





### 8.jvm怎么查看内存占用情况





9.aqs
10.synchronized的底层原理，它是可重入锁吗。怎么实现可重入锁

### 11.常用的数据库引擎，innodb和myisam的区别，hash索引和B+树的区别







### 12.sql优化方式，





13.有a,b,c三列，建了一个 组合索引，和在a上建了索引。现在查询a=？.会选择哪个索引
14.mysql有哪些约束
15.innodb默认的事务隔离级别，要做分布式事务，最高能到哪个隔离级别
16.tcp三次握手，tcp协议是在网络链路哪一层
17.http头部有哪些参数
18.hashmap1.8的改动。写出123456的红黑树
19.集合中有哪些有序的集合
20.linkedhashmap和treemap的区别













### 守护线程

程序结束，直接中断。不可访问固有资源，因为可能随时中断

`Thread.setDaemon()`

### ThreadLocal原理与场景

1.对象跨层传递，避免多次传递
2.线程间数据隔离
3.事务操作，存储线程事务信息
4.数据库连接，session会话管理

内存泄漏原因：

weakreference无论内存是否足够，都会被回收

强软弱虚  









































