[toc]





### 异步与非阻塞

异步是目的.

异步线程中 rpc调用， 网络io多  设置线程数 2n

同步方式读取外部服务时，首先主线程会从**用户模式**进入到**内核模式**，在内核模式中windows会将你的请求数据交给对应的网络驱动程序，继后会让这个线程进入休眠状态

异步方式就是为了解放主线程，步骤三中将thread数据交给网络驱动程序之后，该thread就直接返回不管了，当后续网络驱动程序获取数据后，将数据丢给CLR线程池中的IO线程再由它触发你的回调函数。

![img](../../images/214741-20200420191705462-414122379.png)



### 多线程优先级

子线程默认优先级和父线程一样，Java 主线程默认的优先级是 5。Java 优先级范围是 **[1, 10]**



注解开发 内置tomcat jar包运行  

自动化配置的效果：

spI机制  

排除一些依赖包： exclude  

### MyBatis # $的区别  

\#防止sql注入  $不做转义，传字段、表名

 <if test="aIn != 'A'" >会出现问题，系统会试图把'A'转成数字，改为
 <if test='aIn != "A"' >;



结果集 对一个字段加密： 插件机制 





 一二级缓存：数据一致性问题

 hibnate  



NoSql  

### mongodb优势： 

#### **①弱一致性（最终一致），更能保证用户的访问速度：**

举例来说，在  传统的关系型数据库中，一个COUNT类型的操作会锁定数据集，这样可以保证得到“当前”情况下的精确值。这在某些情况下，例如通过ATM查看账户信息的   时候很重要，但对于Wordnik来说，数据是不断更新和增长的，这种“精确”的保证几乎没有任何意义，反而会产生很大的延迟。他们需要的是一个“大约”  的数字以及更快的处理速度。

但某些情况下MongoDB会锁住数据库。如果此时正有数百个请求，则它们会堆积起来，造成许多问题。我们使用  了下面的优化方式来避免锁定：每次更新前，我们会先查询记录。查询操作会将对象放入内存，于是更新则会尽可能的迅速。在主/从部署方案中，从节点可以使用  “-pretouch”参数运行，这也可以得到相同的效果。使用多个mongod进程。我们根据访问模式将数据库拆分成多个进程。

#### **②文档结构的存储方式，能够更便捷的获取数据。**

对于一个层级式的数据结构来说，如果要将这样的数据使用扁平式的，表状的结构来保存数据，这无论是在查询还是获取数据时都十分困难。

#### **③内置GridFS，支持大容量的存储。**

GridFS是一个出色的分布式文件系统，可以支持海量的数据存储。内置了GridFS了MongoDB，能够满足对大数据集的快速范围查询。

#### **④内置Sharding。**

提供基于Range的AutoSharding机制：一个collection可按照记录的范围，分成若干个段，切分到不同的Shard上。

Shards可以和复制结合，配合Replicasets能够实现Sharding+fail-over，不同的Shard之间可以负载均衡。查询是对客  户端是透明的。客户端执行查询，统计，MapReduce等操作，这些会被MongoDB自动路由到后端的数据节点。这让我们关注于自己的业务，适当的时  候可以无痛的升级。MongoDB的Sharding设计能力最大可支持约20petabytes，足以支撑一般应用。

这可以保证MongoDB运行在便宜的PC服务器集群上。PC集群扩充起来非常方便并且成本很低，避免了“sharding”操作的复杂性和成本。

#### **⑤第三方支持丰富。(这是与其他的NoSQL相比，MongoDB也具有的优势)**

现在网络上的很多NoSQL开源数据库完全属于社区型的，没有官方支持，给使用者带来了很大的风险。

而开源文档数据库MongoDB背后有商业公司10gen为其提供供商业培训和支持。

而且MongoDB社区非常活跃，很多开发框架都迅速提供了对MongDB的支持。不少知名大公司和网站也在生产环境中使用MongoDB，越来越多的创新型企业转而使用MongoDB作为和Django，RoR来搭配的技术方案。

#### **⑥性能优越**

在  使用场合下，千万级别的文档对象，近10G的数据，对有索引的ID的查询不会比[mysql](https://cloud.tencent.com/product/cdb?from=10680)慢，而对非索引字段的查询，则是全面胜出。mysql实际无法胜   任大数据量下任意字段的查询，而mongodb的查询性能实在让我惊讶。写入性能同样很令人满意，同样写入百万级别的数据，mongodb比我以前试用过  的couchdb要快得多，基本10分钟以下可以解决。补上一句，观察过程中mongodb都远算不上是CPU杀手。

#### **与关系型数据库相比，MongoDB的缺点：**

#### **①mongodb不支持事务操作。**

所以事务要求严格的系统（如果银行系统）肯定不能用它。(这点和优点①是对应的)

#### **②mongodb占用空间过大。**

关于其原因，在官方的FAQ中，提到有如下几个方面：

1、  空间的预分配：为避免形成过多的硬盘碎片，mongodb每次空间不足时都会申请生成一大块的硬盘空间，而且申请的量从64M、128M、256M那样的  指数递增，直到2G为单个文件的最大体积。随着数据量的增加，你可以在其数据目录里看到这些整块生成容量不断递增的文件。

2、字段名所占用  的空间：为了保持每个记录内的结构信息用于查询，mongodb需要把每个字段的key-value都以BSON的形式存储，如果value域相对于  key域并不大，比如存放数值型的数据，则数据的overhead是最大的。一种减少空间占用的方法是把字段名尽量取短一些，这样占用空间就小了，但这就   要求在易读性与空间占用上作为权衡了。我曾建议作者把字段名作个index，每个字段名用一个字节表示，这样就不用担心字段名取多长了。但作者的担忧也不   无道理，这种索引方式需要每次查询得到结果后把索引值跟原值作一个替换，再发送到客户端，这个替换也是挺耗费时间的。现在的实现算是拿空间来换取时间吧。

3、删除记录不释放空间：这很容易理解，为避免记录删除后的数据的大规模挪动，原记录空间不删除，只标记“已删除”即可，以后还可以重复利用。

4、可以定期运行db.repairDatabase()来整理记录，但这个过程会比较缓慢

#### **③MongoDB没有如MySQL那样成熟的维护工具，这对于开发和IT运营都是个值得注意的地方**

es和mongodb区别   



设计模式 

工厂模式： 

1.简单工厂： 

2.抽象工厂： 

和建造者什么区别



### 抽象类和接口类

他们的区别如下：
1) 在抽象类中可以写非抽象的方法，从而避免在子类中重复书写他们，这样可以提高代码的复用性，这是抽象类的优势；接口中只能有抽象的方法。
2) 一个类只能继承一个直接父类，这个父类可以是具体的类也可是抽象类；但是一个类可以实现多个接口。

### API和SPI区别

API可以直接使用，SPI一种规范，需要被继承



性能压测 

