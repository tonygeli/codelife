# SpringBoot 修改/解密入参，修改/加密出参

### 一、概念解释：

Servlet规范中的filter引入了一个功能强大的拦截模式。Filter能在request到达servlet的服务方法之前拦截HttpServletRequest对象，而在服务方法转移控制后又能拦截HttpServletResponse对象。

但是HttpServletRequest中的参数是无法改变的，若是手动执行修改request中的参数，则会抛出异常。且无法获取到HttpServletResponse中的输出流中的数据，因为HttpServletResponse中输出流的数据会写入到默认的输出端，你手动无法获取到数据。

我们可以利用**HttpServletRequestWrapper**包装HttpServletRequest，用**HttpServletResponseWrapper**包装HttpServletResponse，**在Wrapper中实现参数的修改或者是response输出流的读取，然后用HttpServletRequestWrapper替换HttpServletRequest，
HttpServletResponseWrapper替换HttpServletResponse。**这样就实现了参数的修改设置和输出流的读取。

### 二、具体实现代码

**修改/解密入参**

```java
/**
 * 解决: request.getInputStream()只能读取一次的问题
 */
@Component
@WebFilter(filterName = "HttpServletRequestFilter", urlPatterns = "/")
@Order(10000)
public class HttpServletRequestFilter implements Filter {

    private static final Logger log = LoggerFactory.getLogger(HttpServletRequestFilter.class);
    @Value("${spring.web.http.salt}")
    private String slat;

    private MultipartResolver multipartResolver;

    public HttpServletRequestFilter(MultipartResolver multipartResolver) {
        this.multipartResolver = multipartResolver;
    }

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        ServletRequest requestWrapper = null;
        String contentType = servletRequest.getContentType();
        //剔除multipart/form-data的情况
      	if(StrUtil.isNotBlank(contentType) && contentType.contains("multipart/form-data")){
            MultipartHttpServletRequest multipartRequest = multipartResolver.resolveMultipart((HttpServletRequest) servletRequest);
            filterChain.doFilter(multipartRequest, servletResponse);
        }
        else{
            if(servletRequest instanceof HttpServletRequest) {
                requestWrapper = new RequestWrapper((HttpServletRequest) servletRequest);
            }
            if(null == requestWrapper) {
                filterChain.doFilter(servletRequest, servletResponse);
            } else {
                filterChain.doFilter(requestWrapper, servletResponse);
            }
        }
    }

    /***
     * HttpServletRequest 包装器
     * 解决: request.getInputStream()只能读取一次的问题
     * 目标: 流可重复读
     */
    public class RequestWrapper extends HttpServletRequestWrapper {

        private Map<String, String[]> paramMap = new HashMap<>();
        /**
         * 请求体
         */
        private String mBody;

        public RequestWrapper(HttpServletRequest request) {
            super(request);
            if(Boolean.parseBoolean(request.getHeader("encrypt"))){
                processDecryption(request);
            }else{
                mBody = getBody(request);
            }
        }

        /**
         * 获取请求参数
         * @param request 请求
         * @return 请求体
         */
        private String getBody(HttpServletRequest request) {
            return HttpContextUtils.getHttpServletRequestParameterMap(request);
        }

        public void setBody(String body){
            this.mBody = body;
        }

        @Override
        public BufferedReader getReader() throws IOException {
            return new BufferedReader(new InputStreamReader(getInputStream()));
        }

        @Override
        public ServletInputStream getInputStream() {
            // 创建字节数组输入流
            final ByteArrayInputStream bais = new ByteArrayInputStream(mBody.getBytes(StandardCharsets.UTF_8));
            return new ServletInputStream() {
                @Override
                public boolean isFinished() {
                    return false;
                }
                @Override
                public boolean isReady() {
                    return false;
                }
                @Override
                public void setReadListener(ReadListener readListener) {
                }
                @Override
                public int read() {
                    return bais.read();
                }
            };
        }

        public void setParamMap(Map<String, String[]> paramMap) {
            this.paramMap = paramMap;
        }
			
				
        @Override
        public Map<String, String[]> getParameterMap() {
            if(!paramMap.isEmpty()){
                return paramMap;
            }
            return super.getParameterMap();
        }

        /**
         * 请求解密处理
         */
        private void processDecryption(HttpServletRequest request) {
            try {
                String requestData = getBody(request);
                //请求方式不为GET
              	if (!StrUtil.equalsIgnoreCase(request.getMethod(), RequestMethod.GET.name())
                    && !StrUtil.equalsIgnoreCase(request.getMethod(), RequestMethod.DELETE.name())) {
                    //对入参进行解密  
                    String decryptRequestData = AesUtil.decrypt(requestData, slat);
                    if(StrUtil.hasBlank(decryptRequestData)){
                        decryptRequestData = requestData;
                    }
                    log.info("Post请求数据解密:{}",decryptRequestData);
                    setBody(decryptRequestData);
                }
                else{
                  // 请求方式为GET
                    Map<String, String[]> paramMap = new HashMap<>();
                    Map<String,Object> hashMap = JSONUtil.parseObj(requestData);
                    for(Map.Entry<String,Object> entry : hashMap.entrySet()){
                        String paramValue = String.valueOf(entry.getValue());
                        String decryptParamValue = AesUtil.decrypt(paramValue, slat);
                        if(StrUtil.hasBlank(decryptParamValue)){
                            decryptParamValue = paramValue;
                        }
                        paramMap.put(entry.getKey(), new String[]{decryptParamValue});
                    }
                    setParamMap(paramMap);
                    log.info("GET请求数据解密:{}",paramMap);
                }
            } catch (Exception e) {
                log.error("请求数据解密失败", e);
                throw new RuntimeException(e);
            }
        }
    }
}
```

**修改/加密出参**

```java
@Component
@WebFilter(filterName = "HttpServletResponseFilter", urlPatterns = "/")
@Order(10000)
public class HttpServletResponseFilter implements Filter {

    private static final Logger log = LoggerFactory.getLogger(HttpServletResponseFilter.class);
    @Value("${spring.web.http.salt}")
    private String slat;

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {

    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        HttpServletRequest req = (HttpServletRequest) servletRequest;
        HttpServletResponse resp = (HttpServletResponse) servletResponse;
        String url = req.getRequestURL().toString();
        
        if(Boolean.parseBoolean(req.getHeader("encrypt"))){
            ResponseWrapper responseWrapper = new ResponseWrapper(resp);
            filterChain.doFilter(req, responseWrapper);
            String responseData = responseWrapper.getResponseData();
            writeEncryptContent(responseData, servletResponse);
        }else{
            filterChain.doFilter(req, resp);
        }
    }


    class ResponseWrapper extends HttpServletResponseWrapper {

        private ServletOutputStream filterOutput;

        private ByteArrayOutputStream output;

        /**
         * Constructs a response adaptor wrapping the given response.
         *
         * @param response The response to be wrapped
         * @throws IllegalArgumentException if the response is null
         */
        public ResponseWrapper(HttpServletResponse response) {
            super(response);
            output = new ByteArrayOutputStream();
        }

        @Override
        public ServletOutputStream getOutputStream() throws IOException {
            if (filterOutput == null) {
                filterOutput = new ServletOutputStream() {
                    @Override
                    public void write(int b) throws IOException {
                        output.write(b);
                    }

                    @Override
                    public boolean isReady() {
                        return false;
                    }

                    @Override
                    public void setWriteListener(WriteListener writeListener) {
                    }
                };
            }
            return filterOutput;
        }

        public String getResponseData() {
            return output.toString();
        }
    }

    /**
     * 输出加密内容
     * @param data
     * @param response
     * @throws IOException
     */
    private void writeEncryptContent(String data, ServletResponse response){
        ServletOutputStream out = null;
        String responseData;
        String encryptData;
        try {
            Map<String,Object> hashMap = JSONUtil.parseObj(data);
           //出参加密 
           encryptData = AesUtil.encrypt(String.valueOf(hashMap.get("data")), slat);
            if(StrUtil.hasBlank(encryptData)){
                responseData = data;
            }else{
                hashMap.put("data",encryptData);
                responseData = JSONUtil.toJsonStr(hashMap);
            }
            response.setCharacterEncoding(StandardCharsets.UTF_8.name());
            response.setContentType("application/json");
            out = response.getOutputStream();
            out.write(responseData.getBytes(StandardCharsets.UTF_8.name()));
            log.info("返回值为:{}",responseData);
        } catch (Exception e) {
            throw new RuntimeException(e);
        } finally {
            if (out != null) {
                try {
                    out.flush();
                    out.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
```

