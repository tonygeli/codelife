# 还在使用kill -9 pid结束spring boot项目吗？

[toc]

## kill -9 pid ？？？

kill可将指定的信息送至程序。预设的信息为SIGTERM(15)，可将指定程序终止。若仍无法终止该程序，可使用SIGKILL(9)信息尝试强制删除程序。程序或工作的编号可利用ps指令或jobs指令查看（这段话来自菜鸟教程）。

讲的这个复杂，简单点来说就是用来杀死linux中的进程，啥？你问我啥是进程？请自行百度。

我相信很多人都用过kill -9 pid 这个命令，彻底杀死进程的意思，一般情况我们使用它没有上面问题，但是在我们项目中使用它就有可能存在致命的问题。

## kill -9 pid 带来的问题

由于kill -9 属于暴力删除，所以会给程序带来比较严重的后果，那究竟会带来什么后果呢？

举个栗子：转账功能，再给两个账户进行加钱扣钱的时候突然断电了？这个时候会发生什么事情？对于InnoDB存储引擎来说，没有什么损失，因为它支持事务，但是对于MyISAM引擎来说那简直就是灾难，为什么？假如给A账户扣了钱，现在需要将B账户加钱，这个时候停电了，就会造成，A的钱被扣了，但是B没有拿到这笔钱，这在生产环境是绝对不允许的，kill -9 相当于突然断电的效果。

当然了，像转账这种，肯定不是使用MyISAM引擎，但是如今分布式火了起来，跨服务转账已经是很平常的事情，这种时候如果使用kill -9 去停止服务，那就不是你的事务能保证数据的准确性了，这个时候你可能会想到分布式事务，这个世界上没有绝对的安全系统或者架构，分布式事务也是一样，他也会存在问题，概率很小，如果一旦发生，损失有可能是无法弥补的，所以一定不能使用kill -9 去停止服务，因为你不知道他会造成什么后果。

在MyISAM引擎中表现的更明显，比如用户的信息由两张表维护，管理员修改用户信息的时候需要修改两张表，但由于你的kill -9 暴力结束项目，导致只修改成功了一张表，这也会导致数据的不一致性，这是小事，因为大不了再修改一次，但是金钱、合同这些重要的信息如果由于你的暴力删除导致错乱，我觉得可能比删库跑路还严重，至少删库还能恢复，你这个都不知道错在哪里。

那我们应该怎么结束项目呢？

其实java给我们提供了结束项目的功能，比如：tomcat可以使用shutdown.bat/shutdown.sh进行优雅结束。

## 什么叫优雅结束？

第一步：停止接收请求和内部线程。
第二步：判断是否有线程正在执行。
第三步：等待正在执行的线程执行完毕。
第四步：停止容器。

以上四步才是正常的结束流程，那springboot怎么正常结束服务呢？下面我介绍几种正常结束服务的方案，请拿好小本本做好笔记。

## 优雅结束服务

### kill -15 pid

这种方式也会比较优雅的结束进程（项目），使用他的时候需要慎重，为什么呢？我们来看个例子

我写了一个普通的controller方法做测试

```java
@GetMapping(value = "/test")
public String test(){
  log.info("test --- start");
  try {
    Thread.sleep(100000);
  } catch (InterruptedException e) {
    e.printStackTrace();
  }
  log.info("test --- end");
  return "test";
}
```

代码很简单，打印：test — start之后让让程序休眠100秒，然后再打印：test — end，在线程休眠中我们使用kill -15 pid来结束这个进程，你们猜 test — end会被打印吗？

```bash
# application.yml
server:
  port: 9988
```


启动项目

`sudo mvn spring-boot:run`
这是maven启动springboot项目的方式,看到这个就代表项目启动成了

![在这里插入图片描述](../../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzMjIwMDg5,size_16,color_FFFFFF,t_70-4851494.png)

找到项目的进程id

`sudo ps -ef |grep shutdown`

![在这里插入图片描述](../../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzMjIwMDg5,size_16,color_FFFFFF,t_70-20210628114027389-4851628.png)

这个就是项目的进程号，接下来我们先测试test接口，让线程进入休眠状态，然后再使用kill -15 14086停止项目

`sudo curl 127.0.0.1:9988/test`
回到项目日志

![在这里插入图片描述](../../images/20200424105352176.png)

我们发现请求已经到达服务，并且线程已经成功进入休眠，现在我们kill -15 14086结束进程

`sudo kill -15 14086`
回到日志

```java
com.ymy.controller.TestController        : test --- start
[extShutdownHook] o.s.s.concurrent.ThreadPoolTaskExecutor  : Shutting down ExecutorService 'applicationTaskExecutor'
java.lang.InterruptedException: sleep interrupted
	at java.lang.Thread.sleep(Native Method)
	at com.ymy.controller.TestController.test(TestController.java:26)

com.ymy.controller.TestController        : test --- end
o.s.web.servlet.HandlerExecutionChain    : HandlerInterceptor.afterCompletion threw exception
java.lang.NullPointerException: null
```

居然报错了，但是test — end是打印出来了，为什么会报错呢？这就和sleep这个方法有关了，在线程休眠期间，当调用线程的interrupt方法的时候会导致sleep抛出异常，这里很明显就是kill -15 这个命令会让程序马上调用线程的interrupt方法，目的是为了让线程停止，虽然让线程停止，但线程什么时候停止还是线程自己说的算，这就是为什么我们还能看到：test — end的原因。

ConfigurableApplicationContext colse
我们先看怎么实现

```java
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@Slf4j
public class TestController  implements ApplicationContextAware {

    private  ApplicationContext  context;

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.context = applicationContext;
    }


    @GetMapping(value = "/test")
    public String test(){
        log.info("test --- start");
        try {
            Thread.sleep(100000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        log.info("test --- end");
        return "test";
    }

    /**
     * 停机
     */
    @PostMapping(value = "shutdown")
    public void shutdown(){
        ConfigurableApplicationContext cyx = (ConfigurableApplicationContext) context;
        cyx.close();
    }
}
```

重点在：`cyx.close();`，为什么他能停止springboot项目呢？请看源码

```java
public void close() {
  synchronized(this.startupShutdownMonitor) {
    this.doClose();
    if (this.shutdownHook != null) 
        Runtime.getRuntime().removeShutdownHook(this.shutdownHook);
  }
}
```

程序在启动的时候向jvm注册了一个关闭钩子，我们在执行colse方法的时候会删除这个关闭钩子，jvm就会知道这是需要停止服务。

我们看测试结果

![在这里插入图片描述](../../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzMjIwMDg5,size_16,color_FFFFFF,t_70-20210628114813867.png)

![在这里插入图片描述](../../images/20200424112210625.png)

很明显，他也出发了线程的interrupt方法导致线程报错，原理和kill -15差不多。

## actuator

这种方式是通过引入依赖的方式停止服务，actuator提供了很多接口，比如健康检查，基本信息等等，我们也可以使用他来优雅的停机。

**引入依赖**

```xml
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```

**application.yml**

```yaml
server:
  port: 9988
management:
  endpoints:
    web:
      exposure:
        include: shutdown
  endpoint:
    shutdown:
      enabled: true
  server:
    port: 8888
```

我这里对actuator的接口重新给定了一个接口，这样可提高安全性，下面我们来测试一下

```java
@RequestMapping(value = "/test",method = RequestMethod.GET)
public String test(){
  System.out.println("test --- start");
  try {
    Thread.sleep(10000);
  } catch (InterruptedException e) {
    e.printStackTrace();
  }
  System.out.println("test --- end");
  return "hello";
}
```

![在这里插入图片描述](../../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzMjIwMDg5,size_16,color_FFFFFF,t_70-20210628115104658.png)

我们发现发送停止服务请求之后还给我们返回了提示信息，很人性化，我们看看控制台

![在这里插入图片描述](../../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzMjIwMDg5,size_16,color_FFFFFF,t_70-20210628115119358.png)

![在这里插入图片描述](../../images/20200424121446880.png)

test — end被执行了，不过在停止线程池的时候还是调用了线程的interrupt方法，导致sleep报错，这三种方式都可以比较优雅的停止springboot服务，如果我项目中存在线程休眠，我希望10秒以后再停止服务可以吗？肯定是可以的，我们只需要稍微做点修改就可以了。

1.新增停止springboot服务类：ElegantShutdownConfig.java

```java
package com.ymy.config;

import org.apache.catalina.connector.Connector;
import org.springframework.boot.web.embedded.tomcat.TomcatConnectorCustomizer;
import org.springframework.context.ApplicationListener;
import org.springframework.context.event.ContextClosedEvent;

import java.util.concurrent.Executor;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

public class ElegantShutdownConfig implements TomcatConnectorCustomizer, ApplicationListener<ContextClosedEvent> {

    private volatile Connector connector;
    private final int waitTime = 10;

    @Override
    public void customize(Connector connector) {
        this.connector = connector;
    }

    @Override
    public void onApplicationEvent(ContextClosedEvent event) {
        connector.pause();
        Executor executor = connector.getProtocolHandler().getExecutor();
        if (executor instanceof ThreadPoolExecutor) {
            try {
                ThreadPoolExecutor threadPoolExecutor = (ThreadPoolExecutor) executor;
                threadPoolExecutor.shutdown();
                if (!threadPoolExecutor.awaitTermination(waitTime, TimeUnit.SECONDS)) {
                    System.out.println("请尝试暴力关闭");
                }
            } catch (InterruptedException ex) {
                System.out.println("异常了");
                Thread.currentThread().interrupt();
            }
        }
    }
}
```

**2.在启动类中加入bean**

```java
package com.ymy;

import com.ymy.config.ElegantShutdownConfig;
import lombok.extern.slf4j.Slf4j;
import org.apache.catalina.connector.Connector;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.web.embedded.tomcat.TomcatConnectorCustomizer;
import org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory;
import org.springframework.boot.web.servlet.server.ServletWebServerFactory;
import org.springframework.context.ApplicationListener;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.event.ContextClosedEvent;

import java.util.concurrent.Executor;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

@SpringBootApplication
public class ShutdownServerApplication {

    public static void main(String[] args) {
        ConfigurableApplicationContext run = SpringApplication.run(ShutdownServerApplication.class, args);
        run.registerShutdownHook();
    }


    @Bean
    public ElegantShutdownConfig elegantShutdownConfig() {
        return new ElegantShutdownConfig();
    }

    @Bean
    public ServletWebServerFactory servletContainer() {
        TomcatServletWebServerFactory tomcat = new TomcatServletWebServerFactory();
        tomcat.addConnectorCustomizers(elegantShutdownConfig());
        return tomcat;
    }
}
```

这样我们就配置好了，我们再来测试一遍，test的接口还是休眠10秒

![在这里插入图片描述](../../images/20200424122006948.png)

我们发现这次没有报错了，他是等待了一段时间之后再结束的线程池，这个时间就是我们在ElegantShutdownConfig类中配置的waitTime。

那可能你会有疑问了，jvm没有立即停止，那这个时候在有请求会发生什么呢？如果关闭的时候有新的请求，服务将不在接收此请求。

数据备份操作
如果我想在服务停止的时候做点备份操作啥的，应该怎么做呢？其实很简单在你要执行的方法上添加一个注解即可：@PreDestroy

Destroy：消灭、毁灭
pre:前缀缩写

所以合在一起的意思就是在容器停止之前执行一次，你可以在这里面做备份操作，也可以做记录停机时间等。

新增服务停止备份工具类：DataBackupConfig.java

```java
import org.springframework.context.annotation.Configuration;
import javax.annotation.PreDestroy;

@Configuration
public class DataBackupConfig {
    @PreDestroy
    public void backData(){
        System.out.println("正在备份数据。。。。。。。。。。。");
    }
}
```

我们再来测试然后打印控制台日志：

![在这里插入图片描述](../../images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzMjIwMDg5,size_16,color_FFFFFF,t_70-20210628115440677.png)